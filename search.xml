<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CentOS离线镜像仓库创建</title>
      <link href="/2021/02/24/centos-chi-xian-jing-xiang-cang-ku-chuang-jian/"/>
      <url>/2021/02/24/centos-chi-xian-jing-xiang-cang-ku-chuang-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS离线镜像仓库创建-以base仓库为例"><a href="#CentOS离线镜像仓库创建-以base仓库为例" class="headerlink" title="CentOS离线镜像仓库创建-以base仓库为例"></a>CentOS离线镜像仓库创建-以base仓库为例</h1><h3 id="一、安装相关软件"><a href="#一、安装相关软件" class="headerlink" title="一、安装相关软件"></a>一、安装相关软件</h3><pre class=" language-sh"><code class="language-sh">yum install createrepo  reposync  yum-utils -y</code></pre><h3 id="二、替换镜像源"><a href="#二、替换镜像源" class="headerlink" title="二、替换镜像源"></a>二、替换镜像源</h3><ol><li>备份</li></ol><pre class=" language-sh"><code class="language-sh">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></pre><ol start="2"><li>下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</li></ol><p>CentOS 7</p><pre class=" language-sh"><code class="language-sh">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</code></pre><p>或者</p><pre class=" language-sh"><code class="language-sh">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</code></pre><h3 id="三、同步镜像-amp-创建本地仓库"><a href="#三、同步镜像-amp-创建本地仓库" class="headerlink" title="三、同步镜像&amp;创建本地仓库"></a>三、同步镜像&amp;创建本地仓库</h3><pre class=" language-sh"><code class="language-sh"># 新建文件夹，存储同步的仓库数据mkdir -p /data/yum.repo && cd /data/yum.repo# 镜像仓库同步reposync -r base -p ./# 创建本地仓库cd base && createrepo ./</code></pre><h3 id="四、离线服务器使用"><a href="#四、离线服务器使用" class="headerlink" title="四、离线服务器使用"></a>四、离线服务器使用</h3><ol><li><p>将同步的镜像仓库打包到离线服务器上，并解压至/mnt/yum.repo/base/下</p></li><li><p>备份</p></li></ol><pre class=" language-sh"><code class="language-sh">mkdir /etc/yum.repos.d/backupmv /etc/yum.repos.d/* /etc/yum.repos.d/backup</code></pre><ol start="3"><li>创建新的 repo 文件 到 /etc/yum.repos.d/</li></ol><pre class=" language-sh"><code class="language-sh">[base]name=CentOS-$releasever - Base - local-base-repofailovermethod=prioritybaseurl=file:///mnt/yum.repo/base/gpgcheck=0</code></pre><ol start="4"><li>运行 yum makecache 生成缓存</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang学习笔记之Select</title>
      <link href="/2020/07/01/golang-xue-xi-bi-ji-zhi-select/"/>
      <url>/2020/07/01/golang-xue-xi-bi-ji-zhi-select/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang学习笔记之Select"><a href="#Golang学习笔记之Select" class="headerlink" title="Golang学习笔记之Select"></a>Golang学习笔记之Select</h1><ul><li><p><strong>直接阻塞</strong>：空 select 语句；空的 select 语句会直接阻塞当前的 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。</p></li><li><p><strong>单一管道</strong>：select 条件只包含一个 case；如果当前的 select 条件只包含一个 case，当 case 中的 Channel 是空指针时，就会直接挂起当前 Goroutine 并永久休眠。</p></li><li><p><strong>非阻塞操作</strong>：当 select 中仅包含两个 case，并且其中一个是 default 时，Go 语言的编译器就会认为这是一次非阻塞的收发操作。如果 select 控制结构中包含 default 语句，那么这个 select 语句在执行时会遇到以下两种情况：</p><pre><code>1.当存在可以收发的 Channel 时，直接处理该 Channel 对应的 case；2.当不存在可以收发的 Channel 是，执行 default 中的语句；</code></pre><p>  当我们运行下面的代码时就不会阻塞当前的 Goroutine，它会直接执行 default 中的代码并返回。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes集群GPU共享解决方案</title>
      <link href="/2020/06/16/kubernetes-ji-qun-gpu-gong-xiang-jie-jue-fang-an/"/>
      <url>/2020/06/16/kubernetes-ji-qun-gpu-gong-xiang-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes集群GPU共享解决方案"><a href="#Kubernetes集群GPU共享解决方案" class="headerlink" title="Kubernetes集群GPU共享解决方案"></a>Kubernetes集群GPU共享解决方案</h1><h3 id="基于阿里云的GPU共享方案"><a href="#基于阿里云的GPU共享方案" class="headerlink" title="基于阿里云的GPU共享方案"></a>基于阿里云的GPU共享方案</h3><p><a href="https://github.com/AliyunContainerService/gpushare-scheduler-extender/blob/master/docs/install.md" target="_blank" rel="noopener">https://github.com/AliyunContainerService/gpushare-scheduler-extender/blob/master/docs/install.md</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 容器化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器学习笔记</title>
      <link href="/2020/06/11/java-rong-qi-xue-xi-bi-ji/"/>
      <url>/2020/06/11/java-rong-qi-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Java容器学习笔记"><a href="#Java容器学习笔记" class="headerlink" title="Java容器学习笔记"></a>Java容器学习笔记</h1><h3 id="ArrayList与LinkList对比："><a href="#ArrayList与LinkList对比：" class="headerlink" title="ArrayList与LinkList对比："></a>ArrayList与LinkList对比：</h3><ul><li>性能：《Java编程思想》指出，ArrayList插入移除元素较慢，ArrayList添加元素的速度比LinkList快。。LinkList插入移除元素速度优于ArrayList，且在数据量大时，ArrayList移除元素异常缓慢（按照元素顺序插入移除，若倒序插入移除则快于LinkList），其中的原因是LinkList使用双向链表存储数据，移除时只需要修改待移除元素的前后节点的next与prev位置即可，而ArrayList则涉及到数组的拷贝，倒序的情况下，ArrayList只需要将末尾元素移除即可。</li><li>建议：在涉及元素删除的List中，建议使用LinkList，其他情况可使用ArrayList。ArrayList使用在查询比较多，但是插入和删除比较少的情况，而LinkedList用在查询比较少而插入删除比较多的情况。</li></ul><h3 id="ArrayList、LinkList、Vector、Stack中只有Stack、Vector是线程安全的类，线程安全的List还有CopyOnWriteArrayList和Collections-synchronizedList-。Collections-synchronizedList-使用装饰模式为传入的List操作加上同步锁。"><a href="#ArrayList、LinkList、Vector、Stack中只有Stack、Vector是线程安全的类，线程安全的List还有CopyOnWriteArrayList和Collections-synchronizedList-。Collections-synchronizedList-使用装饰模式为传入的List操作加上同步锁。" class="headerlink" title="ArrayList、LinkList、Vector、Stack中只有Stack、Vector是线程安全的类，线程安全的List还有CopyOnWriteArrayList和Collections.synchronizedList()。Collections.synchronizedList()使用装饰模式为传入的List操作加上同步锁。"></a>ArrayList、LinkList、Vector、Stack中只有Stack、Vector是线程安全的类，线程安全的List还有CopyOnWriteArrayList和Collections.synchronizedList()。Collections.synchronizedList()使用装饰模式为传入的List操作加上同步锁。</h3><h3 id="Stack底层数据结构是Vector，Vector的所有操作都加了synchronized关键字，Vector的底层使用数组保存数据，类似与ArrayList。一般多线程状态下使用List会选择Vector。"><a href="#Stack底层数据结构是Vector，Vector的所有操作都加了synchronized关键字，Vector的底层使用数组保存数据，类似与ArrayList。一般多线程状态下使用List会选择Vector。" class="headerlink" title="Stack底层数据结构是Vector，Vector的所有操作都加了synchronized关键字，Vector的底层使用数组保存数据，类似与ArrayList。一般多线程状态下使用List会选择Vector。"></a>Stack底层数据结构是Vector，Vector的所有操作都加了synchronized关键字，Vector的底层使用数组保存数据，类似与ArrayList。一般多线程状态下使用List会选择Vector。</h3><h3 id="HashSet底层数据结构是HashMap"><a href="#HashSet底层数据结构是HashMap" class="headerlink" title="HashSet底层数据结构是HashMap"></a>HashSet底层数据结构是HashMap</h3><h3 id="LinkedHashSet底层数据结构是LinkedHashMap"><a href="#LinkedHashSet底层数据结构是LinkedHashMap" class="headerlink" title="LinkedHashSet底层数据结构是LinkedHashMap"></a>LinkedHashSet底层数据结构是LinkedHashMap</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Kafka参数配置详情</title>
      <link href="/2020/06/04/spring-kafka-can-shu-pei-zhi-xiang-qing/"/>
      <url>/2020/06/04/spring-kafka-can-shu-pei-zhi-xiang-qing/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Kafka参数配置详情"><a href="#Spring-Kafka参数配置详情" class="headerlink" title="Spring Kafka参数配置详情"></a>Spring Kafka参数配置详情</h1><h3 id="一、全局配置"><a href="#一、全局配置" class="headerlink" title="一、全局配置"></a>一、全局配置</h3><pre class=" language-yml"><code class="language-yml"># 用逗号分隔的主机:端口对列表，用于建立到Kafka群集的初始连接。覆盖全局连接设置属性spring.kafka.bootstrap-servers# 在发出请求时传递给服务器的ID。用于服务器端日志记录spring.kafka.client-id，默认无# 用于配置客户端的其他属性，生产者和消费者共有的属性spring.kafka.properties.*# 消息发送的默认主题，默认无spring.kafka.template.default-topic</code></pre><h3 id="二、生产者"><a href="#二、生产者" class="headerlink" title="二、生产者"></a>二、生产者</h3><p>Spring Boot中，Kafka 生产者相关配置(所有配置前缀为spring.kafka.producer.)：</p><pre class=" language-yml"><code class="language-yml"># 生产者要求Leader在考虑请求完成之前收到的确认数spring.kafka.producer.acks# 默认批量大小。较小的批处理大小将使批处理不太常见，并可能降低吞吐量（批处理大小为零将完全禁用批处理）spring.kafka.producer.batch-sizespring.kafka.producer.bootstrap-servers# 生产者可用于缓冲等待发送到服务器的记录的总内存大小。spring.kafka.producer.buffer-memory# 在发出请求时传递给服务器的ID。用于服务器端日志记录。spring.kafka.producer.client-id# 生产者生成的所有数据的压缩类型spring.kafka.producer.compression-type# 键的序列化程序类spring.kafka.producer.key-serializerspring.kafka.producer.properties.*# 大于零时，启用失败发送的重试次数spring.kafka.producer.retriesspring.kafka.producer.ssl.key-passwordspring.kafka.producer.ssl.key-store-locationspring.kafka.producer.ssl.key-store-passwordspring.kafka.producer.ssl.key-store-typespring.kafka.producer.ssl.protocolspring.kafka.producer.ssl.trust-store-locationspring.kafka.producer.ssl.trust-store-passwordspring.kafka.producer.ssl.trust-store-type# 非空时，启用对生产者的事务支持spring.kafka.producer.transaction-id-prefixspring.kafka.producer.value-serializer</code></pre><h3 id="三、消费者"><a href="#三、消费者" class="headerlink" title="三、消费者"></a>三、消费者</h3><p>Spring Boot中，Kafka 消费者相关配置(所有配置前缀为spring.kafka.consumer.)：</p><pre class=" language-yml"><code class="language-yml"># 如果“enable.auto.commit”设置为true，设置消费者偏移自动提交到Kafka的频率，默认值无，单位毫秒(ms)spring.kafka.consumer.auto-commit-interval# 当Kafka中没有初始偏移或服务器上不再存在当前偏移时策略设置，默认值无，latest/earliest/none三个值设置# earliest 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费# latest 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据# none topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常spring.kafka.consumer.auto-offset-reset# 用逗号分隔的主机:端口对列表，用于建立到Kafka群集的初始连接。覆盖全局连接设置属性spring.kafka.consumer.bootstrap-servers# 在发出请求时传递给服务器的ID，用于服务器端日志记录spring.kafka.consumer.client-id# 消费者的偏移量是否在后台定期提交spring.kafka.consumer.enable-auto-commit# 如果没有足够的数据来立即满足“fetch-min-size”的要求，则服务器在取回请求之前阻塞的最大时间量spring.kafka.consumer.fetch-max-wait# 服务器应为获取请求返回的最小数据量。spring.kafka.consumer.fetch-min-size# 标识此消费者所属的默认消费者组的唯一字符串spring.kafka.consumer.group-id# 消费者协调员的预期心跳间隔时间。spring.kafka.consumer.heartbeat-interval# 用于读取以事务方式写入的消息的隔离级别。spring.kafka.consumer.isolation-level# 密钥的反序列化程序类spring.kafka.consumer.key-deserializer# 在对poll()的单个调用中返回的最大记录数。spring.kafka.consumer.max-poll-records# 用于配置客户端的其他特定于消费者的属性。spring.kafka.consumer.properties.*# 密钥存储文件中私钥的密码。spring.kafka.consumer.ssl.key-password# 密钥存储文件的位置。spring.kafka.consumer.ssl.key-store-location# 密钥存储文件的存储密码。spring.kafka.consumer.ssl.key-store-password# 密钥存储的类型，如JKSspring.kafka.consumer.ssl.key-store-type# 要使用的SSL协议，如TLSv1.2, TLSv1.1, TLSv1spring.kafka.consumer.ssl.protocol# 信任存储文件的位置。spring.kafka.consumer.ssl.trust-store-location# 信任存储文件的存储密码。spring.kafka.consumer.ssl.trust-store-password# 信任存储区的类型。spring.kafka.consumer.ssl.trust-store-type# 值的反序列化程序类。spring.kafka.consumer.value-deserializer</code></pre><h3 id="四、监听器"><a href="#四、监听器" class="headerlink" title="四、监听器"></a>四、监听器</h3><p>Spring Boot中，Kafka Listener相关配置(所有配置前缀为spring.kafka.listener.)：</p><pre class=" language-yml"><code class="language-yml"># ackMode为“COUNT”或“COUNT_TIME”时偏移提交之间的记录数spring.kafka.listener.ack-count=spring.kafka.listener.ack-modespring.kafka.listener.ack-timespring.kafka.listener.client-idspring.kafka.listener.concurrencyspring.kafka.listener.idle-event-intervalspring.kafka.listener.log-container-config# 如果Broker上不存在至少一个配置的主题（topic），则容器是否无法启动，# 该设置项结合Broker设置项allow.auto.create.topics=true，如果为false，则会自动创建不存在的topicspring.kafka.listener.missing-topics-fatal=true# 非响应消费者的检查间隔时间。如果未指定持续时间后缀，则将使用秒作为单位spring.kafka.listener.monitor-intervalspring.kafka.listener.no-poll-thresholdspring.kafka.listener.poll-timeoutspring.kafka.listener.type</code></pre><h3 id="五、管理"><a href="#五、管理" class="headerlink" title="五、管理"></a>五、管理</h3><pre class=" language-yml"><code class="language-yml">spring.kafka.admin.client-id# 如果启动时代理不可用，是否快速失败spring.kafka.admin.fail-fast=falsespring.kafka.admin.properties.*spring.kafka.admin.ssl.key-passwordspring.kafka.admin.ssl.key-store-locationspring.kafka.admin.ssl.key-store-passwordspring.kafka.admin.ssl.key-store-typespring.kafka.admin.ssl.protocolspring.kafka.admin.ssl.trust-store-locationspring.kafka.admin.ssl.trust-store-passwordspring.kafka.admin.ssl.trust-store-type</code></pre><h3 id="六、授权服务-JAAS"><a href="#六、授权服务-JAAS" class="headerlink" title="六、授权服务(JAAS)"></a>六、授权服务(JAAS)</h3><pre class=" language-yml"><code class="language-yml">spring.kafka.jaas.control-flag=requiredspring.kafka.jaas.enabled=falsespring.kafka.jaas.login-module=com.sun.security.auth.module.Krb5LoginModulespring.kafka.jaas.options.*</code></pre><h3 id="七、SSL认证"><a href="#七、SSL认证" class="headerlink" title="七、SSL认证"></a>七、SSL认证</h3><pre class=" language-yml"><code class="language-yml">spring.kafka.ssl.key-passwordspring.kafka.ssl.key-store-locationspring.kafka.ssl.key-store-passwordspring.kafka.ssl.key-store-typespring.kafka.ssl.protocolspring.kafka.ssl.trust-store-locationspring.kafka.ssl.trust-store-passwordspring.kafka.ssl.trust-store-type</code></pre><h3 id="八、Stream流处理"><a href="#八、Stream流处理" class="headerlink" title="八、Stream流处理"></a>八、Stream流处理</h3><pre class=" language-yml"><code class="language-yml">spring.kafka.streams.application-idspring.kafka.streams.auto-startupspring.kafka.streams.bootstrap-serversspring.kafka.streams.cache-max-size-bufferingspring.kafka.streams.client-idspring.kafka.streams.properties.*spring.kafka.streams.replication-factorspring.kafka.streams.ssl.key-passwordspring.kafka.streams.ssl.key-store-locationspring.kafka.streams.ssl.key-store-passwordspring.kafka.streams.ssl.key-store-typespring.kafka.streams.ssl.protocolspring.kafka.streams.ssl.trust-store-locationspring.kafka.streams.ssl.trust-store-passwordspring.kafka.streams.ssl.trust-store-typespring.kafka.streams.state-dir</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/05/18/she-ji-mo-shi-jian-jie/"/>
      <url>/2020/05/18/she-ji-mo-shi-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><h3 id="一、设计模式原则"><a href="#一、设计模式原则" class="headerlink" title="一、设计模式原则"></a>一、设计模式原则</h3><ul><li><p><strong>开闭原则</strong>：开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：<strong>软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification）</strong>，这就是开闭原则的经典定义。</p></li><li><p><strong>里氏替换原则</strong>：里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：<strong>继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）</strong>。</p></li><li><p><strong>依赖倒置原则</strong>：依赖倒置原则（Dependence Inversion Principle，DIP）的原始定义为，<strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）</strong>。其核心思想是：<strong>要面向接口编程，不要面向实现编程</strong>。</p></li><li><p><strong>单一职责原则</strong>：单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特·C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定<strong>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）</strong>。</p></li><li><p><strong>接口隔离原则</strong>：接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p></li><li><p><strong>迪米特法则</strong>：迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：<strong>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用</strong>。其目的是降低类之间的耦合度，提高模块的相对独立性。</p></li><li><p><strong>合成复用原则</strong>：合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要<strong>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</strong>。</p></li></ul><h3 id="二、设计模式分类"><a href="#二、设计模式分类" class="headerlink" title="二、设计模式分类"></a>二、设计模式分类</h3><ol><li><p>根据目的来分</p><p> 根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。</p><ul><li><p>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</p></li><li><p>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p></li><li><p>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p></li></ul></li><li><p>根据作用范围来分</p><p> 根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。</p><ul><li><p>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</p></li><li><p>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。</p><p>表 1 介绍了这 23 种设计模式的分类。</p><table><thead><tr><th>范围\目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr><td>类模式</td><td>工厂方法    (类）</td><td>适配器</td><td>模板方法、解释器</td></tr><tr><td>对象模式</td><td>单例<br>原型<br>抽象工厂<br>建造者</td><td>代理<br>(对象）适配器<br>桥接<br>装饰<br>外观<br>享元<br>组合</td><td>策略<br>命令<br>职责链<br>状态<br>观察者<br>中介者<br>迭代器<br>访问者<br>备忘录</td></tr></tbody></table></li></ul></li><li><p>GoF的23种设计模式的功能</p><p> 前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。</p><ul><li><p>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p></li><li><p>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p></li><li><p>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</p></li><li><p>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p></li><li><p>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p></li><li><p>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</p></li><li><p>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p></li><li><p>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p></li><li><p>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</p></li><li><p>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p></li><li><p>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</p></li><li><p>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p></li><li><p>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p></li><li><p>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</p></li><li><p>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</p></li><li><p>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</p></li><li><p>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</p></li><li><p>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</p></li><li><p>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</p></li><li><p>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p></li><li><p>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</p></li><li><p>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</p></li><li><p>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p></li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Compose安装使用</title>
      <link href="/2020/03/17/dockercompose-an-zhuang-shi-yong/"/>
      <url>/2020/03/17/dockercompose-an-zhuang-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-Compose安装使用"><a href="#Docker-Compose安装使用" class="headerlink" title="Docker Compose安装使用"></a>Docker Compose安装使用</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Compose是用于定义和运行多容器Docker应用程序的工具。通过Compose，您可以使用YAML文件来配置应用程序的服务。然后，使用一个命令，就可以从配置中创建并启动所有服务。</p><p>使用Compose基本上是一个三步过程：</p><ul><li><p>打包应用镜像</p></li><li><p>使用docker-compose.yml文件定义应用服务</p></li><li><p>运行docker-compose up 启动服务</p><p>如下是一个redis服务的docker-compose.yml文件：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'2.0'</span><span class="token key atrule">services</span><span class="token punctuation">:</span><span class="token key atrule">web</span><span class="token punctuation">:</span> <span class="token key atrule">build</span><span class="token punctuation">:</span> . <span class="token key atrule">ports</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span> <span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> .<span class="token punctuation">:</span>/code <span class="token punctuation">-</span> logvolume01<span class="token punctuation">:</span>/var/log <span class="token key atrule">links</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> redis<span class="token key atrule">redis</span><span class="token punctuation">:</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token key atrule">volumes</span><span class="token punctuation">:</span><span class="token key atrule">logvolume01</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Compose是用于定义和运行多容器应用的工具。通过Compose，您可以使用YAML文件来配置应用程序的服务。然后，使用一个命令，就可以从配置中创建并启动所有服务。例如：一个Wordpress项目包含mysql数据库和wordpress应用，首先创建docker-compose.yml文件（建议在wordpress文件夹下创建，方便管理），然后在docker-compose.yml文件所在的目录下运行“docker-compose up -d”，Compose就会通过配置创建并启动Wordpress。</p><h3 id="一、安装Docker-Compose"><a href="#一、安装Docker-Compose" class="headerlink" title="一、安装Docker Compose"></a>一、安装Docker Compose</h3><p>系统环境</p></li></ul><table><thead><tr><th>Host Name</th><th>OS</th><th>IP</th></tr></thead><tbody><tr><td>master1</td><td>CentOS 7.5</td><td>192.168.56.114</td></tr></tbody></table><p>通过如下命令下载Docker Compose</p><pre class=" language-sh"><code class="language-sh"># 下载docker-compose-1.25.4并保存至/usr/local/bin/目录下sudo curl -L "https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose# 修改docker-compose权限为可运行sudo chmod +x /usr/local/bin/docker-compose</code></pre><h3 id="二、Compose常用命令简介"><a href="#二、Compose常用命令简介" class="headerlink" title="二、Compose常用命令简介"></a>二、Compose常用命令简介</h3><p> 本文只介绍在生产环境中经常会用到的几个命令，关于其他命令，可通过“docker-compose help”命令查询，或者查询<a href="https://docs.docker.com/compose/reference/overview/" target="_blank" rel="noopener">Docker官方网站</a></p><ul><li><p>docker-compose up</p><p>应用启动/更新命令，构建、（重新）创建、启动并附加到服务的容器。“docker-compose up”命令后可跟参数，</p></li></ul><ol><li>-d：后台运行应用，类似docker run -d；</li><li>–force-recreate：强制重新生成容器；</li></ol><p>其他命令可查询官方文档。</p><ul><li><p>docker-compose down</p><p>停止应用所有容器并删除compose创建的网络，存储和容器。</p><h3 id="三、docker-compose-yml介绍"><a href="#三、docker-compose-yml介绍" class="headerlink" title="三、docker-compose.yml介绍"></a>三、docker-compose.yml介绍</h3></li></ul><p>下面是wordpress应用的docker-compose.yml的内容，各部分介绍将会通过该文件展开：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.3'</span><span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">app-tier</span><span class="token punctuation">:</span>    <span class="token key atrule">driver</span><span class="token punctuation">:</span> bridge<span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">db</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> db_data<span class="token punctuation">:</span>/var/lib/mysql    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> somewordpress      <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">MYSQL_USER</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">MYSQL_PASSWORD</span><span class="token punctuation">:</span> wordpress    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> app<span class="token punctuation">-</span>tier  <span class="token key atrule">wordpress</span><span class="token punctuation">:</span>    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> db    <span class="token key atrule">image</span><span class="token punctuation">:</span> wordpress<span class="token punctuation">:</span>latest    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"8000:80"</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">WORDPRESS_DB_HOST</span><span class="token punctuation">:</span> db<span class="token punctuation">:</span><span class="token number">3306</span>      <span class="token key atrule">WORDPRESS_DB_USER</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">WORDPRESS_DB_PASSWORD</span><span class="token punctuation">:</span> wordpress      <span class="token key atrule">WORDPRESS_DB_NAME</span><span class="token punctuation">:</span> wordpress    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> app<span class="token punctuation">-</span>tier<span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token key atrule">db_data</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li><p>services</p><p>配置应用运行的服务，wordpress应用配置了mysql数据库服务db和业务应用wordpress。服务配置说明如下：</p></li></ul><ol><li>image：服务运行的Docker镜像；</li><li>volumes：存储挂载，可挂载应用配置的volumes或者直接挂载宿主机路径,如：“- /opt/mysql/data:/var/lib/mysql”</li><li>restart：服务重启策略。always：宕机自动重启；</li><li>environment：环境变量配置；</li><li>networks：服务网络配置；</li></ol><ul><li><p>networks</p><p>配置应用运行的网络，服务通过networks指定镜像运行使用的网络。</p></li><li><p>volumes</p><p>配置存储，服务可通过volumes挂载。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
            <tag> docker-compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fluent-bit日志插件配置说明</title>
      <link href="/2020/03/06/fluent-bit-ri-zhi-cha-jian-pei-zhi-shuo-ming/"/>
      <url>/2020/03/06/fluent-bit-ri-zhi-cha-jian-pei-zhi-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h1 id="Fluent-bit日志插件配置说明"><a href="#Fluent-bit日志插件配置说明" class="headerlink" title="Fluent-bit日志插件配置说明"></a>Fluent-bit日志插件配置说明</h1><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>fluent-bit配置文件中，主要由输入（Input）、解析器（Parser）、过滤器（Filter）、缓存（Buffer）、路由（Routing）、输出（Output）六大模块组成，各个模块的详细说明如下：</p><p><img src="/medias/logging_pipeline.png" alt="fluent-bit数据流图"></p><table><thead><tr><th>Interface</th><th>Description(英文)</th><th>Description(中文)</th></tr></thead><tbody><tr><td>Input</td><td>Entry point of data. Implemented through Input Plugins, this interface allows to gather or receive data. E.g: log file content, data over TCP, built-in metrics, etc.</td><td>数据的入口点。通过输入插件实现，此接口允许收集或接收数据。例如：日志文件内容，TCP上的数据，内置指标等。</td></tr><tr><td>Parser</td><td>Parsers allow to convert unstructured data gathered from the Input interface into a structured one. Parsers are optional and depends on Input plugins.</td><td>解析器允许将从Input接口收集的非结构化数据转换为结构化数据。解析器是可选的，并且取决于Input插件。</td></tr><tr><td>Filter</td><td>The filtering mechanism allows to alter the data ingested by the Input plugins. Filters are implemented as plugins.</td><td>过滤机制允许更改 Input插件提取的数据。过滤器被实现为插件。</td></tr><tr><td>Buffer</td><td>By default, the data ingested by the Input plugins, resides in memory until is routed and delivered to an Output interface.</td><td>默认情况下，Input插件提取的数据将驻留在内存中，直到路由并传递到Output接口为止。</td></tr><tr><td>Routing</td><td>Data ingested by an Input interface is tagged, that means that a Tag is assigned and this one is used to determinate where the data should be routed based on a match rule.</td><td>Input接口摄取的数据被标记，这意味着分配了一个Tag，并且该标记用于根据匹配规则确定应将数据路由到的位置。</td></tr><tr><td>Output</td><td>An output defines a destination for the data. Destinations are handled by output plugins. Note that thanks to the Routing interface, the data can be delivered to multiple destinations.</td><td>输出定义数据的目的地。目的地由输出插件处理。请注意，借助“路由”接口，可以将数据传递到多个目的地。</td></tr></tbody></table><h3 id="二、配置文件"><a href="#二、配置文件" class="headerlink" title="二、配置文件"></a>二、配置文件</h3><p>一个fluent-bit配置文件除了包括输入（Input）、解析器（Parser）、过滤器（Filter）、缓存（Buffer）、路由（Routing）、输出（Output）六个模块外，还需要配置Service，该模块主要负责fluent-bit的配置，如Parser配置文件路径、fluent-bit自身日志打印等。如下是fluent-bit.conf配置：</p><pre><code>[SERVICE]    Flush        1    Daemon       Off    Log_Level    debug    Parsers_File parsers.conf[INPUT]    Name             tail    Path             ${K8S_LOG_DIR}/*.log    Parser           json    Tag              kube_file.*    Refresh_Interval 5    Mem_Buf_Limit    5MB    Skip_Long_Lines  OFF[FILTER]    Name             record_modifier    Match            kube_file.*    Record           hostname ${K8S_HOSTNAME}    Record           namespace ${K8S_POD_NAMESPACE}    Record           application ${K8S_APPLICATION_NAME}    Record           pod ${K8S_POD_NAME}    Record           container ${K8S_CONTAINER_NAME}    Record           node ${K8S_NODE_NAME}[OUTPUT]    Name             es    Match            *    Host             ${ELASTICSEARCH_HOST}    Port             ${ELASTICSEARCH_PORT}    Logstash_Format  On    Retry_Limit      False    Type             flb_type    Time_Key         time    Time_Key_Format  yyyy-MM-dd HH:mm:ss.SSS    Replace_Dots     On    Logstash_Prefix  segma_application_file</code></pre><h3 id="三、Service"><a href="#三、Service" class="headerlink" title="三、Service"></a>三、Service</h3><p>Service各个配置项如下：</p><table><thead><tr><th>Key</th><th>Description</th><th>中文描述</th><th>Default Value</th></tr></thead><tbody><tr><td>Flush</td><td>Set the flush time in seconds. Everytime it timeouts, the engine will flush the records to the output plugin.</td><td>设置Flush时间（以秒为单位）。每次超时，引擎都会将记录刷新到输出插件。</td><td>5</td></tr><tr><td>Daemon</td><td>Boolean value to set if Fluent Bit should run as a Daemon (background) or not. Allowed values are: yes, no, on and off.</td><td>一个布尔值，用于设置Fluent Bit是否应作为守护程序（后台）运行。允许的值为：是，否，打开和关闭。</td><td>Off</td></tr><tr><td>Log_File</td><td>Absolute path for an optional log file.</td><td>可选日志文件的绝对路径。</td><td>-</td></tr><tr><td>Log_Level</td><td>Set the logging verbosity level. Allowed values are: error, info, debug and trace. Values are accumulative, e.g: if ‘debug’ is set, it will include error, info and debug. Note that trace mode is only available if Fluent Bit was built with the WITH_TRACE option enabled.</td><td>设置日志记录的详细程度。允许的值为：error, info, debug 和 trace。值是累积值，例如：如果设置了“ debug”，则它将包括error, info 和 debug。请注意，只有在启用WITH_TRACE选项的情况下构建Fluent Bit时，跟踪模式才可用。</td><td>info</td></tr><tr><td>Parsers_File</td><td>Path for a parsers configuration file. Multiple Parsers_File entries can be used.</td><td>配置文件的路径。可以使用多个Parsers_File条目。</td><td>-</td></tr><tr><td>HTTP_Server</td><td>Enable built-in HTTP Server</td><td>启用内置的HTTP服务器</td><td>Off</td></tr><tr><td>HTTP_Listen</td><td>Set listening interface for HTTP Server when it’s enabled</td><td>启用HTTP Server时设置监听接口</td><td>0.0.0.0</td></tr><tr><td>HTTP_Port</td><td>Set TCP Port for the HTTP Server</td><td>设置HTTP服务器的TCP端口</td><td>2020</td></tr></tbody></table><p>在Kubernetes中进行日志收集时，一般需要配置的项有：Flush、Daemon、Log_Level、Parsers_File。在调试插件时，关闭Daemon以及设置Log_Level为debug甚至更高可方便查看插件运行错误。Parsers_File对应解析器的配置，可参考官方提供的<a href="https://raw.githubusercontent.com/fluent/fluent-bit/master/conf/parsers.conf" target="_blank" rel="noopener">parsers.conf</a></p><h3 id="四、Input"><a href="#四、Input" class="headerlink" title="四、Input"></a>四、Input</h3><p>INPUT模块指点了日志输入源，每个输入插件都可以添加自己的配置键。以下为目前官方支持的输入源插件,<a href="https://fluentbit.io/documentation/0.13/input/" target="_blank" rel="noopener">官方Input Plugins</a>。运行在kubernetes集群内的应用日志收集时，我们使用的是tail插件常用参数如下：</p><table><thead><tr><th>Key</th><th>Description</th><th>中文描述</th><th>Default</th></tr></thead><tbody><tr><td>Buffer_Chunk_Size</td><td>Set the initial buffer size to read files data. This value is used too to increase buffer size. The value must be according to the Unit Size specification.</td><td>设置初始缓冲区大小以读取文件数据。该值也用于增加缓冲区大小。该值必须符合“ 单位大小”规范。</td><td>32k</td></tr><tr><td>Buffer_Max_Size</td><td>Set the limit of the buffer size per monitored file. When a buffer needs to be increased (e.g: very long lines), this value is used to restrict how much the memory buffer can grow. If reading a file exceed this limit, the file is removed from the monitored file list. The value must be according to the Unit Size specification.</td><td>设置每个受监视文件的缓冲区大小的限制。当需要增加缓冲区时（例如：很长的行），该值用于限制内存缓冲区可以增长多少。如果读取的文件超过此限制，将从监视的文件列表中删除该文件。该值必须符合“ 单位大小”规范。</td><td>Buffer_Chunk_Size</td></tr><tr><td>Path</td><td>Pattern specifying a specific log files or multiple ones through the use of common wildcards.</td><td>通过使用通用通配符指定一个或多个特定日志文件的模式。</td><td></td></tr><tr><td>Path_Key</td><td>If enabled, it appends the name of the monitored file as part of the record. The value assigned becomes the key in the map.</td><td>如果启用，它将附加受监视文件的名称作为记录的一部分。分配的值成为映射中的键。</td><td></td></tr><tr><td>Exclude_Path</td><td>Set one or multiple shell patterns separated by commas to exclude files matching a certain criteria, e.g: exclude_path=<em>.gz,</em>.zip</td><td>设置一个或多个用逗号分隔的外壳模式，以排除符合特定条件的文件，例如：exclude_path = <em>.gz，</em>.zip</td><td></td></tr><tr><td>Refresh_Interval</td><td>The interval of refreshing the list of watched files. Default is 60 seconds.</td><td>刷新监视文件列表的时间间隔。默认值为60秒。</td><td></td></tr><tr><td>Rotate_Wait</td><td>Specify the number of extra seconds to monitor a file once is rotated in case some pending data is flushed. Default is 5 seconds.</td><td>指定在刷新某些未决数据时旋转一次后监视文件的额外秒数。默认值为5秒。</td><td></td></tr><tr><td>Skip_Long_Lines</td><td>When a monitored file reach it buffer capacity due to a very long line (Buffer_Max_Size), the default behavior is to stop monitoring that file. Skip_Long_Lines alter that behavior and instruct Fluent Bit to skip long lines and continue processing other lines that fits into the buffer size.</td><td>当受监视的文件由于行很长（Buffer_Max_Size）而达到缓冲区容量时，默认行为是停止监视该文件。Skip_Long_Lines会更改该行为，并指示Fluent Bit跳过长行并继续处理适合缓冲区大小的其他行。</td><td>Off</td></tr><tr><td>DB</td><td>Specify the database file to keep track of monitored files and offsets.</td><td>指定数据库文件以跟踪受监视的文件和偏移量。</td><td></td></tr><tr><td>DB.Sync</td><td>Set a default synchronization (I/O) method. Values: Extra, Full, Normal, Off. This flag affects how the internal SQLite engine do synchronization to disk, for more details about each option please refer to this section.</td><td>设置默认的同步（I / O）方法。值：Extra，Full，Normal，Off。此标志影响内部SQLite引擎与磁盘同步的方式，有关每个选项的更多详细信息，请参阅本节。</td><td>Full</td></tr><tr><td>Mem_Buf_Limit</td><td>Set a limit of memory that Tail plugin can use when appending data to the Engine. If the limit is reach, it will be paused; when the data is flushed it resumes.</td><td>设置将数据附加到引擎时，Tail插件可以使用的内存限制。如果达到极限，它将被暂停；刷新数据后，它将恢复。</td><td></td></tr><tr><td>Parser</td><td>Specify the name of a parser to interpret the entry as a structured message.</td><td>指定解析器的名称，以将条目解释为结构化消息。</td><td></td></tr><tr><td>Key</td><td>When a message is unstructured (no parser applied), it’s appended as a string under the key name log. This option allows to define an alternative name for that key.</td><td>当消息是非结构化消息（未应用解析器）时，它将作为字符串附加在键名log下。此选项允许为该键定义替代名称。</td><td>log</td></tr></tbody></table><p>常用的参数有Path、Parser、Tag、Refresh_Interval、Mem_Buf_Limit、Skip_Long_Lines。Path指定日志所在目录；Tag为Routing参数，会在Routing章节介绍；Refresh_Interval指定日志刷新时间间隔，会直接影响日志收集的实时性，一般设置为5秒；Mem_Buf_Limit指定插件内存大小，一般设置5Mb;Skip_Long_Lines一般使用默认值Off；其中比较重要的是Parser参数的配置，主要匹配Parser解析器，其值为解析器的name值，下一章介绍Parser解析器。</p><h3 id="五、Parser"><a href="#五、Parser" class="headerlink" title="五、Parser"></a>五、Parser</h3><p>Parser解析器的配置是单独的一个配置文件，配置的加载是由Service模块的Parsers_File参数指定。可参考官方提供的<a href="https://raw.githubusercontent.com/fluent/fluent-bit/master/conf/parsers.conf" target="_blank" rel="noopener">parsers.conf</a></p><h3 id="六、Filter"><a href="#六、Filter" class="headerlink" title="六、Filter"></a>六、Filter</h3><p>Filter插件允许改变输入数据的结构，例如在Kubernetes集群中，我们需要日志记录应用的名字以及所在节点，而默认日志未打印该值，我们便可以使用Filter附加该值。详情见<a href="https://fluentbit.io/documentation/0.13/filter/" target="_blank" rel="noopener">官方插件</a>信息</p><h3 id="七、Buffer"><a href="#七、Buffer" class="headerlink" title="七、Buffer"></a>七、Buffer</h3><p>当准备好将数据或日志路由到某个目标位置时，默认情况下会将它们缓冲在内存中。</p><h3 id="八、Routing"><a href="#八、Routing" class="headerlink" title="八、Routing"></a>八、Routing</h3><p>路由是一项核心功能，可让您通过过滤器将数据路由到一个或多个目的地。路由主要由两个参数控制。</p><ul><li>Tag：当数据由输入插件生成时，它附带一个标签（大多数情况下是手动配置该标签），该标签是人类可读的指示器，有助于识别数据源。</li><li>Match：我们定义其中的数据应被路由，一个匹配规则在配置中进行分配。</li></ul><p>下面文件将简单介绍路由规则的实现：</p><pre><code>[INPUT]    Name cpu    Tag  my_cpu[INPUT]    Name mem    Tag  my_mem[OUTPUT]    Name   es    Match  my_cpu[OUTPUT]    Name   stdout    Match  my_mem</code></pre><p>在上面的配置中，es输出通过Match值my_cpu匹配到输入插件cpu的Tag值，而stdout输出则通过Match值my_mem匹配到输入插件mem的Tag值，所以es输出只接收cpu输出，stdout输出只接收mem输出。</p><h3 id="九、Output"><a href="#九、Output" class="headerlink" title="九、Output"></a>九、Output</h3><p>输出接口允许定义数据的目的地。通用目标是远程服务，本地文件系统或其他标准接口。输出实现为插件，并且有很多可用的插件。<br>有关更多详细信息，请参阅“<a href="https://fluentbit.io/documentation/0.13/output/" target="_blank" rel="noopener">输出插件</a>”部分。</p><p>Filter</p><h3 id="附录-Fluent-bit官方文档"><a href="#附录-Fluent-bit官方文档" class="headerlink" title="附录 Fluent-bit官方文档"></a>附录 Fluent-bit官方文档</h3><p><a href="https://fluentbit.io/documentation/0.13/configuration/file.html" target="_blank" rel="noopener">https://fluentbit.io/documentation</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 日志 </tag>
            
            <tag> Fluent-Bit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FTP服务器搭建</title>
      <link href="/2020/02/19/ftp-fu-wu-qi-da-jian/"/>
      <url>/2020/02/19/ftp-fu-wu-qi-da-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="FTP服务搭建"><a href="#FTP服务搭建" class="headerlink" title="FTP服务搭建"></a>FTP服务搭建</h1><ul><li>系统： centos 7.4</li></ul><h3 id="一、安装vsftpd"><a href="#一、安装vsftpd" class="headerlink" title="一、安装vsftpd"></a>一、安装vsftpd</h3><pre class=" language-sh"><code class="language-sh">yum -y install vsftpd</code></pre><h3 id="二、配置服务"><a href="#二、配置服务" class="headerlink" title="二、配置服务"></a>二、配置服务</h3><pre class=" language-sh"><code class="language-sh">[root@ecs-7fd0 vsftpd]# cat /etc/vsftpd/vsftpd.confanonymous_enable=NOlocal_enable=YESwrite_enable=YESlocal_umask=022dirmessage_enable=YESxferlog_enable=YESxferlog_std_format=YESascii_upload_enable=YESascii_download_enable=YESchroot_local_user=YESlisten=NOlisten_ipv6=YESconnect_from_port_20=NO#设置使用主动模式pasv_enable=YESpasv_min_port=1024pasv_max_port=65536pam_service_name=vsftpdguest_enable=YES#设置使用虚拟用户的真实访问用户guest_username=ftpuseruser_config_dir=/etc/vsftpd/vsftpd_user_confallow_writeable_chroot=YES#设置使用虚拟用户virtual_use_local_privs=YESuserlist_enable=YESuserlist_deny=NOtcp_wrappers=YES</code></pre><h3 id="三、创建ftpuser账户"><a href="#三、创建ftpuser账户" class="headerlink" title="三、创建ftpuser账户"></a>三、创建ftpuser账户</h3><pre class=" language-sh"><code class="language-sh">useradd -d /home/ftpuser -s /sbin/nologin ftpuser</code></pre><h3 id="三、虚拟用户"><a href="#三、虚拟用户" class="headerlink" title="三、虚拟用户"></a>三、虚拟用户</h3><ul><li>设置pam策略</li></ul><pre class=" language-sh"><code class="language-sh">[root@ecs-7fd0 vsftpd]# cat /etc/pam.d/vsftpd#%PAM-1.0#session    optional     pam_keyinit.so    force revoke#auth       required    pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed#auth       required    pam_shells.so#auth       include    password-auth#account    include    password-auth#session    required     pam_loginuid.so#session    include    password-authauth       required    pam_userdb.so   db=/etc/vsftpd/vsftpd_loginaccount    required    pam_userdb.so   db=/etc/vsftpd/vsftpd_login</code></pre><ul><li>配置虚拟账户</li></ul><pre class=" language-sh"><code class="language-sh">[root@ecs-7fd0 vsftpd]# cat ftp_virtual_user User001PasswordForUser001User002PasswordForUser002User003PasswordForUser003</code></pre><ul><li>生成虚拟账号数据库</li></ul><pre class=" language-sh"><code class="language-sh">[root@ecs-7fd0 vsftpd]# db_load -T -t hash -f /etc/vsftpd/ftp_virtual_user /etc/vsftpd/vsftpd_login.db</code></pre><ul><li>配置虚拟账户访问目录</li></ul><pre class=" language-sh"><code class="language-sh">[root@ecs-7fd0 vsftpd]# mkdir -p /etc/vsftpd/vsftpd_user_conf[root@ecs-7fd0 vsftpd]# cat User001local_root=/home/ftpuser/User001write_enable=YESanon_world_readable_only=YESanon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YES[root@ecs-7fd0 vsftpd]# cat User002local_root=/home/ftpuser/User002write_enable=YESanon_world_readable_only=YESanon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YES[root@ecs-7fd0 vsftpd]# cat User003local_root=/home/ftpuser/User003write_enable=YESanon_world_readable_only=YESanon_upload_enable=YESanon_mkdir_write_enable=YESanon_other_write_enable=YES</code></pre><ul><li>启动vsftpd</li></ul><pre class=" language-sh"><code class="language-sh">[root@ecs-7fd0 vsftpd]# systemctl enable vsftpd[root@ecs-7fd0 vsftpd]# systemctl start vsftpd</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> FTP </tag>
            
            <tag> 共享存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ceph集群安装</title>
      <link href="/2020/02/14/ceph-ji-qun-an-zhuang/"/>
      <url>/2020/02/14/ceph-ji-qun-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="CephFS集群安装"><a href="#CephFS集群安装" class="headerlink" title="CephFS集群安装"></a>CephFS集群安装</h1><h3 id="一、集群规划"><a href="#一、集群规划" class="headerlink" title="一、集群规划"></a>一、集群规划</h3><table><thead><tr><th>节点</th><th>ip</th><th>os</th><th>节点说明</th></tr></thead><tbody><tr><td>master1</td><td>10.73.13.61</td><td>centos7.4</td><td>mon+rgw+manger节点、ceph-deploy</td></tr><tr><td>master2</td><td>10.73.13.60</td><td>centos7.4</td><td>mon+rgw+manger节点</td></tr><tr><td>master3</td><td>10.73.13.59</td><td>centos7.4</td><td>mon+rgw+manger节点</td></tr></tbody></table><h3 id="二、安装ceph-deploy"><a href="#二、安装ceph-deploy" class="headerlink" title="二、安装ceph-deploy"></a>二、安装ceph-deploy</h3><ol><li>Install and enable the Extra Packages for Enterprise Linux (EPEL) repository:Install and enable the Extra Packages for Enterprise Linux (EPEL) repository:</li></ol><pre class=" language-sh"><code class="language-sh">sudo yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</code></pre><ol start="2"><li>添加ceph仓库（阿里源，同时在所有节点进行如下操作）</li></ol><pre class=" language-sh"><code class="language-sh">cat << EOM > /etc/yum.repos.d/ceph.repo[Ceph]name=Ceph packages for $basearchbaseurl=https://mirrors.aliyun.com/ceph/rpm-mimic/el7/$basearchenabled=1gpgcheck=1type=rpm-mdgpgkey=https://download.ceph.com/keys/release.ascpriority=1[Ceph-noarch]name=Ceph noarch packagesbaseurl=https://mirrors.aliyun.com/ceph/rpm-mimic/el7/noarchenabled=1gpgcheck=1type=rpm-mdgpgkey=https://download.ceph.com/keys/release.ascpriority=1[ceph-source]name=Ceph source packagesbaseurl=https://mirrors.aliyun.com/ceph/rpm-mimic/el7/SRPMSenabled=1EOM</code></pre><ol start="3"><li>安装python-setuptools、ceph-deploy</li></ol><pre class=" language-sh"><code class="language-sh">sudo yum install python-setuptoolssudo yum install ceph-deploy</code></pre><h3 id="三、节点准备"><a href="#三、节点准备" class="headerlink" title="三、节点准备"></a>三、节点准备</h3><p>以下操作需在所有节点进行。</p><ol><li>免密登录</li></ol><pre class=" language-sh"><code class="language-sh"># 1、三次回车后，密钥生成完成ssh-keygen# 2、拷贝密钥到其他节点ssh-copy-id -i ~/.ssh/id_rsa.pub  用户名字@192.168.x.xxx</code></pre><ol start="2"><li>时间同步</li></ol><p>网上教程很多，具体可参考网上文档。</p><pre class=" language-sh"><code class="language-sh">sudo yum install ntpdatentpdate -u ntp.api.bz</code></pre><ol start="3"><li>关闭SELinux、防火墙</li></ol><pre class=" language-sh"><code class="language-sh">systemctl stop firewalldsystemctl disable firewalldsetenforce 0sed -i "s/SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/config</code></pre><ol start="4"><li>关闭系统的Swap（Kubernetes 1.8开始要求）</li></ol><pre class=" language-sh"><code class="language-sh">swapoff -ayes | cp /etc/fstab /etc/fstab_bakcat /etc/fstab_bak |grep -v swap > /etc/fstab</code></pre><h3 id="四、集群安装"><a href="#四、集群安装" class="headerlink" title="四、集群安装"></a>四、集群安装</h3><p>以下操作在ceph-deploy节点。</p><ol><li>创建集群</li></ol><pre class=" language-sh"><code class="language-sh">mkdir /etc/ceph && cd /etc/ceph# ceph-deploy new {initial-monitor-node(s)}ceph-deploy new master1 master2 master3 </code></pre><ol start="2"><li>设置集群配置</li></ol><ul><li>具体集群配置说明，待后续更新</li></ul><pre class=" language-sh"><code class="language-sh">cat /etc/ceph/ceph.conf[global]public_network = 10.73.13.0/16cluster_network = 10.73.13.0/16fsid = 464c2aa2-7426-4d6b-a0ae-961d1589ee53mon_initial_members = master1, master2, master3mon_host = 10.73.13.61,10.73.13.60,10.73.13.59auth_cluster_required = cephxauth_service_required = cephxauth_client_required = cephxosd_pool_default_size = 3osd_pool_default_min_size = 1osd_pool_default_pg_num = 8osd_pool_default_pgp_num = 8osd_crush_chooseleaf_type = 1[mon]mon_clock_drift_allowed = 0.5mon allow pool delete = true[osd]osd_mkfs_type = xfsosd_mkfs_options_xfs = -ffilestore_max_sync_interval = 5filestore_min_sync_interval = 0.1filestore_fd_cache_size = 655350filestore_omap_header_cache_size = 655350filestore_fd_cache_random = trueosd op threads = 8osd disk threads = 4filestore op threads = 8max_open_files = 655350[mgr]mgr modules = dashboard</code></pre><ol start="3"><li>为所有节点安装ceph</li></ol><pre class=" language-sh"><code class="language-sh"># ceph-deploy install {initial-monitor-node(s)} --no-adjust-repos# --no-adjust-repos参数的意思是不更新节点配置的ceph源，因为在安装ceph-deploy的步骤下已经为节点配置了阿里云的ceph源ceph-deploy new master1 master2 master3 --no-adjust-repos</code></pre><ol start="4"><li>初始化节点配置,生产相应的keys</li></ol><pre class=" language-sh"><code class="language-sh">ceph-deploy mon create-initial</code></pre><p>完成之后会在/etc/ceph目录下生成以下几个文件</p><pre class=" language-sh"><code class="language-sh">ceph.client.admin.keyringceph.bootstrap-mgr.keyringceph.bootstrap-osd.keyringceph.bootstrap-mds.keyringceph.bootstrap-rgw.keyringceph.bootstrap-rbd.keyringceph.bootstrap-rbd-mirror.keyring</code></pre><ol start="5"><li>拷贝文件至部署节点</li></ol><pre class=" language-sh"><code class="language-sh">ceph-deploy admin master1 master2 master3</code></pre><ol start="6"><li>部署mgr</li></ol><pre class=" language-sh"><code class="language-sh">ceph-deploy mgr create master1 master2 master3</code></pre><ol start="7"><li>添加OSD</li></ol><pre class=" language-sh"><code class="language-sh">ceph-deploy osd create --data /dev/vdb master1ceph-deploy osd create --data /dev/vdb master2ceph-deploy osd create --data /dev/vdb master3</code></pre><h3 id="五、创建CephFS文件系统"><a href="#五、创建CephFS文件系统" class="headerlink" title="五、创建CephFS文件系统"></a>五、创建CephFS文件系统</h3><ol><li>部署metadata服务</li></ol><pre class=" language-sh"><code class="language-sh">ceph-deploy mds create master1 master2 master3</code></pre><ol start="2"><li>生成CephFS</li></ol><pre class=" language-sh"><code class="language-sh">ceph osd pool create cephfs_data 128ceph osd pool create cephfs_meta 128ceph fs new mycephfs cephfs_meta cephfs_data</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Ceph </tag>
            
            <tag> 分布式存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes集群运行问题记录</title>
      <link href="/2020/01/02/kubernetes-ji-qun-yun-xing-wen-ti-ji-lu/"/>
      <url>/2020/01/02/kubernetes-ji-qun-yun-xing-wen-ti-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="kubernetes集群运行问题记录"><a href="#kubernetes集群运行问题记录" class="headerlink" title="kubernetes集群运行问题记录"></a>kubernetes集群运行问题记录</h1><ul><li><p>集群内部容器无法解析外部DNS</p><p>原因：由于节点名为nodex.domain.xx，集群内部容器的/etc/resolv.conf中search域会domain.xx域，容器在解析外网域名时默认会先在外网域名后添加.domain.xx进行域名解析，而外网存在域名domain.xx，且DNS解析域名为<em>.domain.xx，所以会将外网域名解析至</em>.domain.xx对应的IP地址，最终导致容器内部无法访问外网域名。</p><p>解决办法：尽量避免集群内部节点名与外网域名冲突，可采用domain.local结尾等命名方式为节点命名。</p></li><li><p>gitlab迁移之后系统异常</p><p>原因：集群新建gitlab仓库各组件之间的认证文件与原有gialab不一致，导致恢复数据之后部分组件之间交互异常。</p><p>解决办法：新建gitlab之前，迁移原有gitlab中所有的secret文件。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 容器化 </tag>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes集群安装Cert Manager</title>
      <link href="/2019/12/31/kubernetes-ji-qun-an-zhuang-cert-manager/"/>
      <url>/2019/12/31/kubernetes-ji-qun-an-zhuang-cert-manager/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Cert-Manager"><a href="#安装Cert-Manager" class="headerlink" title="安装Cert Manager"></a>安装Cert Manager</h1><h3 id="一、Installing-the-Chart"><a href="#一、Installing-the-Chart" class="headerlink" title="一、Installing the Chart"></a>一、Installing the Chart</h3><p><a href="https://cert-manager.io/docs/installation/kubernetes/" target="_blank" rel="noopener">https://cert-manager.io/docs/installation/kubernetes/</a></p><h3 id="二、创建ClusterIssuer-集群内所有命名空间公用方案"><a href="#二、创建ClusterIssuer-集群内所有命名空间公用方案" class="headerlink" title="二、创建ClusterIssuer(集群内所有命名空间公用方案)"></a>二、创建ClusterIssuer(集群内所有命名空间公用方案)</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> cert<span class="token punctuation">-</span>manager.io/v1alpha2<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterIssuer<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>letsencrypt<span class="token punctuation">-</span>prod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">acme</span><span class="token punctuation">:</span>    <span class="token key atrule">email</span><span class="token punctuation">:</span> hnbcao@qq.com    <span class="token key atrule">privateKeySecretRef</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>letsencrypt<span class="token punctuation">-</span>prod    <span class="token key atrule">server</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//acme<span class="token punctuation">-</span>v02.api.letsencrypt.org/directory    <span class="token key atrule">solvers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">http01</span><span class="token punctuation">:</span>        <span class="token key atrule">ingress</span><span class="token punctuation">:</span>          <span class="token key atrule">class</span><span class="token punctuation">:</span> traefik</code></pre><h3 id="三、创建Issuer-集群内单个命名空间独享方案"><a href="#三、创建Issuer-集群内单个命名空间独享方案" class="headerlink" title="三、创建Issuer(集群内单个命名空间独享方案)"></a>三、创建Issuer(集群内单个命名空间独享方案)</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> cert<span class="token punctuation">-</span>manager.io/v1alpha2<span class="token key atrule">kind</span><span class="token punctuation">:</span> Issuer<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> letsencrypt<span class="token punctuation">-</span>prod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">acme</span><span class="token punctuation">:</span>    <span class="token key atrule">email</span><span class="token punctuation">:</span> hnbcao@qq.com    <span class="token key atrule">privateKeySecretRef</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> letsencrypt<span class="token punctuation">-</span>prod    <span class="token key atrule">server</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//acme<span class="token punctuation">-</span>v02.api.letsencrypt.org/directory    <span class="token key atrule">solvers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">http01</span><span class="token punctuation">:</span>        <span class="token key atrule">ingress</span><span class="token punctuation">:</span>          <span class="token key atrule">class</span><span class="token punctuation">:</span> traefik</code></pre><h3 id="四、Ingress应用ClusterIssuer"><a href="#四、Ingress应用ClusterIssuer" class="headerlink" title="四、Ingress应用ClusterIssuer"></a>四、Ingress应用ClusterIssuer</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> harbor<span class="token punctuation">-</span>ingress  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ns<span class="token punctuation">-</span>harbor  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> harbor    <span class="token key atrule">chart</span><span class="token punctuation">:</span> harbor    <span class="token key atrule">heritage</span><span class="token punctuation">:</span> Helm    <span class="token key atrule">release</span><span class="token punctuation">:</span> harbor  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">cert-manager.io/cluster-issuer</span><span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>letsencrypt<span class="token punctuation">-</span>prod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">tls</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> harbor.domian.io      <span class="token key atrule">secretName</span><span class="token punctuation">:</span> harbor<span class="token punctuation">-</span>letsencrypt<span class="token punctuation">-</span>tls  <span class="token key atrule">rules</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> harbor.domian.io      <span class="token key atrule">http</span><span class="token punctuation">:</span>        <span class="token key atrule">paths</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /            <span class="token key atrule">backend</span><span class="token punctuation">:</span>              <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> harbor<span class="token punctuation">-</span>harbor<span class="token punctuation">-</span>portal              <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><p>Ingress通过在annotations中添加cert-manager.io/cluster-issuer: cluster-letsencrypt-prod为ingress中的域名自动生成证书。</p><h3 id="四、Ingress应用ClusterIssuer-1"><a href="#四、Ingress应用ClusterIssuer-1" class="headerlink" title="四、Ingress应用ClusterIssuer"></a>四、Ingress应用ClusterIssuer</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Ingress<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> harbor<span class="token punctuation">-</span>ingress  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ns<span class="token punctuation">-</span>harbor  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> harbor    <span class="token key atrule">chart</span><span class="token punctuation">:</span> harbor    <span class="token key atrule">heritage</span><span class="token punctuation">:</span> Helm    <span class="token key atrule">release</span><span class="token punctuation">:</span> harbor  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">cert-manager.io/issuer</span><span class="token punctuation">:</span> letsencrypt<span class="token punctuation">-</span>prod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">tls</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> harbor.domian.io      <span class="token key atrule">secretName</span><span class="token punctuation">:</span> harbor<span class="token punctuation">-</span>letsencrypt<span class="token punctuation">-</span>tls  <span class="token key atrule">rules</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> harbor.domian.io      <span class="token key atrule">http</span><span class="token punctuation">:</span>        <span class="token key atrule">paths</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">path</span><span class="token punctuation">:</span> /            <span class="token key atrule">backend</span><span class="token punctuation">:</span>              <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> harbor<span class="token punctuation">-</span>harbor<span class="token punctuation">-</span>portal              <span class="token key atrule">servicePort</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><p>Ingress通过在annotations中添加cert-manager.io/issuer: letsencrypt-prod为ingress中的域名自动生成证书。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><ul><li>使用Cert Manager时，ingress中host配置的域名必须指定，不能有通配符；</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 容器化 </tag>
            
            <tag> Kubernetes优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes集群创建用户</title>
      <link href="/2019/12/31/kubernetes-ji-qun-chuang-jian-yong-hu/"/>
      <url>/2019/12/31/kubernetes-ji-qun-chuang-jian-yong-hu/</url>
      
        <content type="html"><![CDATA[<h1 id="创建集群用户"><a href="#创建集群用户" class="headerlink" title="创建集群用户"></a>创建集群用户</h1><p>1、创建用户</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token punctuation">-</span>user  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>   <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token punctuation">-</span>user  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token key atrule">rbac.authorization.kubernetes.io/autoupdate</span><span class="token punctuation">:</span> <span class="token string">"true"</span><span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>admin<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token punctuation">-</span>user  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system</code></pre><p>2、获取管理员用户的Token，通过执行如下命令获取系统Token信息</p><pre class=" language-sh"><code class="language-sh">kubectl describe secret admin-user --namespace=kube-system</code></pre><p>3、导入kubeconfig文件</p><pre class=" language-sh"><code class="language-sh">DASH_TOCKEN=$(kubectl get secret -n kube-system admin-user-token-4j272 -o jsonpath={.data.token}|base64 -d)kubectl config set-cluster kubernetes --server=https://172.16.0.9:8443 --kubeconfig=/root/kube-admin.confkubectl config set-credentials admin-user --token=$DASH_TOCKEN --kubeconfig=/root/kube-admin.confkubectl config set-context admin-user@kubernetes --cluster=kubernetes --user=admin-user --kubeconfig=/root/kube-admin.confkubectl config use-context admin-user@kubernetes --kubeconfig=/root/kube-admin.conf</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 容器化 </tag>
            
            <tag> Kubernetes优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes集群跨namespace服务访问</title>
      <link href="/2019/12/31/kubernetes-ji-qun-kua-namespace-fu-wu-fang-wen/"/>
      <url>/2019/12/31/kubernetes-ji-qun-kua-namespace-fu-wu-fang-wen/</url>
      
        <content type="html"><![CDATA[<h1 id="集群跨namespace服务访问"><a href="#集群跨namespace服务访问" class="headerlink" title="集群跨namespace服务访问"></a>集群跨namespace服务访问</h1><hr><p>ns-02需要访问ns-01下面的服务service01</p><hr><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> service02 <span class="token key atrule">namespace</span><span class="token punctuation">:</span> ns<span class="token punctuation">-</span><span class="token number">02</span><span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token key atrule">ports</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http   <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>   <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP   <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span> <span class="token key atrule">sessionAffinity</span><span class="token punctuation">:</span> None <span class="token key atrule">type</span><span class="token punctuation">:</span> ExternalName <span class="token key atrule">externalName</span><span class="token punctuation">:</span> service01.ns<span class="token punctuation">-</span>01.svc.cluster.local</code></pre><ul><li>externalName：需要访问的服务域名，service01指服务名字，ns-01指命名空间，svc.cluster.local指kubernetes内部服务域名结尾，默认是svc.cluster.local</li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 容器化 </tag>
            
            <tag> Kubernetes优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes集群创建Image Pull Secret</title>
      <link href="/2019/12/31/kubernetes-ji-qun-chuang-jian-image-pull-secret/"/>
      <url>/2019/12/31/kubernetes-ji-qun-chuang-jian-image-pull-secret/</url>
      
        <content type="html"><![CDATA[<h1 id="创建ImagePullSecret"><a href="#创建ImagePullSecret" class="headerlink" title="创建ImagePullSecret"></a>创建ImagePullSecret</h1><h3 id="一、登录镜像仓库，成功之后会生成如下-root-docker-config-json文件"><a href="#一、登录镜像仓库，成功之后会生成如下-root-docker-config-json文件" class="headerlink" title="一、登录镜像仓库，成功之后会生成如下/root/.docker/config.json文件"></a>一、登录镜像仓库，成功之后会生成如下/root/.docker/config.json文件</h3><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"auths"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"harbor.hnbcao.tech"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"auth"</span><span class="token operator">:</span> <span class="token string">"YWRtaW4******lRlY2g="</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"HttpHeaders"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"User-Agent"</span><span class="token operator">:</span> <span class="token string">"Docker-Client/***"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="二、执行如下命令创建ImagePullSecret"><a href="#二、执行如下命令创建ImagePullSecret" class="headerlink" title="二、执行如下命令创建ImagePullSecret"></a>二、执行如下命令创建ImagePullSecret</h3><pre class=" language-sh"><code class="language-sh">kubectl create secret generic harbor-admin-secret --from-file=.dockerconfigjson=/root/.docker/config.json --type=kubernetes.io/dockerconfigjson --namespace hnbcao-mixing-ore</code></pre><p>说明：</p><ul><li>harbor-admin-secret： ImagePullSecret名字</li><li>type： 指定secret类型为kubernetes.io/dockerconfigjson</li><li>namespace：secret命名空间</li></ul><h3 id="四、为项目添加ImagePullSecret"><a href="#四、为项目添加ImagePullSecret" class="headerlink" title="四、为项目添加ImagePullSecret"></a>四、为项目添加ImagePullSecret</h3><ul><li>Deployment</li></ul><p>在配置项的spec.template.spec.imagePullSecrets下添加secret：harbor-admin-secret。例如，Deployment的配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>test<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app.kubernetes.io/instance</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>test      <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> hnbcao  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app.kubernetes.io/instance</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>test        <span class="token key atrule">app.kubernetes.io/name</span><span class="token punctuation">:</span> hnbcao    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> hnbcao          <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx      <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> harbor<span class="token punctuation">-</span>admin<span class="token punctuation">-</span>secret</code></pre><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>附上官网教程：<a href="https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 容器化 </tag>
            
            <tag> Kubernetes优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes集群安装Traefik Ingress</title>
      <link href="/2019/12/31/kubernetes-ji-qun-an-zhuang-traefik-ingress/"/>
      <url>/2019/12/31/kubernetes-ji-qun-an-zhuang-traefik-ingress/</url>
      
        <content type="html"><![CDATA[<h1 id="部署TraefikIngress"><a href="#部署TraefikIngress" class="headerlink" title="部署TraefikIngress"></a>部署TraefikIngress</h1><h3 id="使用OpenSSL创建TLS证书（已有证书则跳过该选项）"><a href="#使用OpenSSL创建TLS证书（已有证书则跳过该选项）" class="headerlink" title="使用OpenSSL创建TLS证书（已有证书则跳过该选项）"></a>使用OpenSSL创建TLS证书（已有证书则跳过该选项）</h3><ul><li>设置证书信息</li></ul><pre class=" language-sh"><code class="language-sh">cd ~ && mkdir tls echo """[req] distinguished_name = req_distinguished_nameprompt = yes[ req_distinguished_name ]countryName                     = Country Name (2 letter code)countryName_value               = CNstateOrProvinceName             = State or Province Name (full name)stateOrProvinceName_value       = ChongqinglocalityName                    = Locality Name (eg, city)localityName_value              = YubeiorganizationName                = Organization Name (eg, company)organizationName_value          = HNBCAOorganizationalUnitName          = Organizational Unit Name (eg, section)organizationalUnitName_value    = R & D DepartmentcommonName                      = Common Name (eg, your name or your server\'s hostname)commonName_value                = *.hnbcao.ioemailAddress                    = Email AddressemailAddress_value              = hnbcao@163.com""" > ~/tls/openssl.cnf</code></pre><ul><li>生成证书</li></ul><pre class=" language-sh"><code class="language-sh">openssl req -newkey rsa:4096 -nodes -config ~/tls/openssl.cnf -days 3650 -x509 -out ~/tls/tls.crt -keyout ~/tls/tls.key</code></pre><h3 id="部署Traefik"><a href="#部署Traefik" class="headerlink" title="部署Traefik"></a>部署Traefik</h3><ul><li>添加证书至集群</li></ul><pre class=" language-sh"><code class="language-sh">kubectl create -n kube-system secret tls ssl --cert ~/ikube/tls/tls.crt --key ~/ikube/tls/tls.key</code></pre><ul><li>部署Traefik</li></ul><pre class=" language-sh"><code class="language-sh">kubectl apply -f https://raw.githubusercontent.com/hnbcao/kubeadm-ha/master/addons/yaml/traefik/traefik-daemonset-full.yaml</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 容器化 </tag>
            
            <tag> Kubernetes优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes集群安装</title>
      <link href="/2019/12/31/kubernetes-ji-qun-an-zhuang/"/>
      <url>/2019/12/31/kubernetes-ji-qun-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes集群搭建"><a href="#Kubernetes集群搭建" class="headerlink" title="Kubernetes集群搭建"></a>Kubernetes集群搭建</h1><ul><li>1、本文基于<a href="https://www.kubernetes.org.cn/4948.html" target="_blank" rel="noopener">kubeadm HA master(v1.13.0)离线包 + 自动化脚本 + 常用插件 For Centos/Fedora</a>编写，修改了master之间的负载均衡方式为HAProxy+keeplived方式。</li><li>2、此离线教程必须保证目标安装环境与离线包下载环境一致，或者是考虑做yum镜像源。</li><li>3、关于keepalived+haproxy负载均衡，由于是在阿里云上搭建的，事实上是没有实现的，至于为何也成功部署了环境，其实是每台机器上keepalived都处于激活状态，对虚拟ip的访问都映射到了本机，本机又通过haproxy将请求负载到了api-server上。这是个神奇的事情，直到现在才搞清楚keepalived+haproxy的原理，如果是在阿里云上部署，这块建议使用阿里云的负载均衡功能。（keepalived+haproxy是为了实现api-server的负载均衡）</li><li>4、关于内核，实际上升不升级应该问题都不是很大，至少目前环境没出现过问题。</li><li>5、关于kubernetes版本，目前该教程能支持最新的v1.15.3版本的安装，注意修改版本号。</li></ul><p>集群方案：</p><ul><li>发行版：CentOS 7</li><li>容器运行时</li><li>内核： 4.18.12-1.el7.elrepo.x86_64</li><li>版本：Kubernetes: 1.14.0</li><li>网络方案: Calico</li><li>kube-proxy mode: IPVS</li><li>master高可用方案：HAProxy keepalived LVS</li><li>DNS插件: CoreDNS</li><li>metrics插件：metrics-server</li><li>界面：kubernetes-dashboard</li></ul><h3 id="一、环境概述"><a href="#一、环境概述" class="headerlink" title="一、环境概述"></a>一、环境概述</h3><table><thead><tr><th>Host Name</th><th>Role</th><th>IP</th></tr></thead><tbody><tr><td>master1</td><td>master1</td><td>192.168.56.103</td></tr><tr><td>master2</td><td>master2</td><td>192.168.56.104</td></tr><tr><td>master3</td><td>master3</td><td>192.168.56.105</td></tr><tr><td>node1</td><td>node1</td><td>192.168.56.106</td></tr><tr><td>node2</td><td>node2</td><td>192.168.56.107</td></tr><tr><td>node3</td><td>node3</td><td>192.168.56.108</td></tr></tbody></table><h3 id="二、离线仓库制作（可选）"><a href="#二、离线仓库制作（可选）" class="headerlink" title="二、离线仓库制作（可选）"></a>二、离线仓库制作（可选）</h3><p>具体制作方式见：<a href="https://hnbcao.vip/2021/02/24/centos-chi-xian-jing-xiang-cang-ku-chuang-jian/" target="_blank" rel="noopener">CentOS离线镜像仓库创建</a></p><p>需要制作的离线仓库有：</p><ol><li>base repo</li></ol><pre class=" language-sh"><code class="language-sh">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</code></pre><ol><li>docker repo</li></ol><pre class=" language-sh"><code class="language-sh">[docker-ce-stable]name=Docker CE Stable - $basearchbaseurl=https://download.docker.com/linux/centos/$releasever/$basearch/stableenabled=1gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-stable-debuginfo]name=Docker CE Stable - Debuginfo $basearchbaseurl=https://download.docker.com/linux/centos/$releasever/debug-$basearch/stableenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-stable-source]name=Docker CE Stable - Sourcesbaseurl=https://download.docker.com/linux/centos/$releasever/source/stableenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-test]name=Docker CE Test - $basearchbaseurl=https://download.docker.com/linux/centos/$releasever/$basearch/testenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-test-debuginfo]name=Docker CE Test - Debuginfo $basearchbaseurl=https://download.docker.com/linux/centos/$releasever/debug-$basearch/testenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-test-source]name=Docker CE Test - Sourcesbaseurl=https://download.docker.com/linux/centos/$releasever/source/testenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-nightly]name=Docker CE Nightly - $basearchbaseurl=https://download.docker.com/linux/centos/$releasever/$basearch/nightlyenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-nightly-debuginfo]name=Docker CE Nightly - Debuginfo $basearchbaseurl=https://download.docker.com/linux/centos/$releasever/debug-$basearch/nightlyenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg[docker-ce-nightly-source]name=Docker CE Nightly - Sourcesbaseurl=https://download.docker.com/linux/centos/$releasever/source/nightlyenabled=0gpgcheck=1gpgkey=https://download.docker.com/linux/centos/gpg</code></pre><ol start="2"><li>kubernetes repo</li></ol><pre class=" language-sh"><code class="language-sh">cat <<EOF > /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF</code></pre><h3 id="三、软件安装"><a href="#三、软件安装" class="headerlink" title="三、软件安装"></a>三、软件安装</h3><pre class=" language-sh"><code class="language-sh"># 安装ifconfigyum install net-tools -y# 时间同步yum install -y ntpdate# 安装docker（建议18.06.3.ce）## 列出Docker版本yum list docker-ce --showduplicates | sort -r## 安装指定版本sudo yum install docker-ce-<VERSION_STRING>eg:sudo yum install docker-ce-18.06.3.ce# 安装文件管理器，XShell可通过rz sz命令上传或者下载服务器文件yum install lrzsz -y# 安装keepalived、haproxyyum install -y socat keepalived ipvsadm haproxy# 安装kubernetes相关组件# 建议指定各个软件的版本号，使用yum list 软件名（如kubelet） --showduplicates | sort -r列出版本号。yum install -y kubelet kubeadm kubectl ebtables# 其他软件安装yum install wget</code></pre><h3 id="四、节点系统配置"><a href="#四、节点系统配置" class="headerlink" title="四、节点系统配置"></a>四、节点系统配置</h3><ul><li>关闭SELinux、防火墙</li></ul><pre class=" language-sh"><code class="language-sh">systemctl stop firewalldsystemctl disable firewalldsetenforce 0sed -i "s/SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/config</code></pre><ul><li>关闭系统的Swap（Kubernetes 1.8开始要求）</li></ul><pre class=" language-sh"><code class="language-sh">swapoff -ayes | cp /etc/fstab /etc/fstab_bakcat /etc/fstab_bak |grep -v swap > /etc/fstab</code></pre><ul><li>配置L2网桥在转发包时会被iptables的FORWARD规则所过滤，该配置被CNI插件需要，更多信息请参考<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#network-plugin-requirements" target="_blank" rel="noopener">Network Plugin Requirements</a></li></ul><pre class=" language-sh"><code class="language-sh">echo """vm.swappiness = 0net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1""" > /etc/sysctl.confsysctl -p</code></pre><p><a href="https://www.cnblogs.com/zejin2008/p/7102485.html" target="_blank" rel="noopener">centos7添加bridge-nf-call-ip6tables出现No such file or directory</a>,简单来说就是执行一下 modprobe br_netfilter</p><ul><li>同步时间</li></ul><pre class=" language-sh"><code class="language-sh">ntpdate -u ntp.api.bz</code></pre><ul><li>升级内核到最新（已准备内核离线安装包，可选）</li></ul><p><a href="https://www.aliyun.com/jiaocheng/130885.html" target="_blank" rel="noopener">centos7 升级内核</a></p><p><a href="https://www.kubernetes.org.cn/5163.html" target="_blank" rel="noopener">参考文章</a></p><pre class=" language-sh"><code class="language-sh">grub2-set-default 0 && grub2-mkconfig -o /etc/grub2.cfggrubby --default-kernelgrubby --args="user_namespace.enable=1" --update-kernel="$(grubby --default-kernel)"</code></pre><ul><li>重启系统，确认内核版本后，开启IPVS（如果未升级内核，去掉ip_vs_fo）</li></ul><pre class=" language-sh"><code class="language-sh">uname -acat > /etc/sysconfig/modules/ipvs.modules <<EOF#!/bin/bashipvs_modules="ip_vs ip_vs_lc ip_vs_wlc ip_vs_rr ip_vs_wrr ip_vs_lblc ip_vs_lblcr ip_vs_dh ip_vs_sh ip_vs_fo ip_vs_nq ip_vs_sed ip_vs_ftp nf_conntrack"for kernel_module in \${ipvs_modules}; do /sbin/modinfo -F filename \${kernel_module} > /dev/null 2>&1 if [ $? -eq 0 ]; then /sbin/modprobe \${kernel_module} fidoneEOFchmod 755 /etc/sysconfig/modules/ipvs.modules && bash /etc/sysconfig/modules/ipvs.modules && lsmod | grep ip_vs</code></pre><p>执行sysctl -p报错可执行modprobe br_netfilter，请参考<a href="https://www.cnblogs.com/zejin2008/p/7102485.html" target="_blank" rel="noopener">centos7添加bridge-nf-call-ip6tables出现No such file or directory</a></p><ul><li>所有机器需要设定/etc/sysctl.d/k8s.conf的系统参数(可选)</li></ul><pre class=" language-sh"><code class="language-sh"># https://github.com/moby/moby/issues/31208 # ipvsadm -l --timout# 修复ipvs模式下长连接timeout问题 小于900即可cat <<EOF > /etc/sysctl.d/k8s.confnet.ipv4.tcp_keepalive_time = 600net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_keepalive_probes = 10net.ipv6.conf.all.disable_ipv6 = 1net.ipv6.conf.default.disable_ipv6 = 1net.ipv6.conf.lo.disable_ipv6 = 1net.ipv4.neigh.default.gc_stale_time = 120net.ipv4.conf.all.rp_filter = 0net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.default.arp_announce = 2net.ipv4.conf.lo.arp_announce = 2net.ipv4.conf.all.arp_announce = 2net.ipv4.ip_forward = 1net.ipv4.tcp_max_tw_buckets = 5000net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 1024net.ipv4.tcp_synack_retries = 2net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.netfilter.nf_conntrack_max = 2310720fs.inotify.max_user_watches=89100fs.may_detach_mounts = 1fs.file-max = 52706963fs.nr_open = 52706963net.bridge.bridge-nf-call-arptables = 1vm.swappiness = 0vm.overcommit_memory=1vm.panic_on_oom=0EOFsysctl --system</code></pre><ul><li>设置开机启动</li></ul><pre class=" language-sh"><code class="language-sh"># 启动dockersed -i "13i ExecStartPost=/usr/sbin/iptables -P FORWARD ACCEPT" /usr/lib/systemd/system/docker.servicesystemctl daemon-reloadsystemctl enable dockersystemctl start docker# 设置kubelet开机启动systemctl enable kubeletsystemctl enable keepalivedsystemctl enable haproxy</code></pre><ul><li>设置免密登录</li></ul><pre class=" language-sh"><code class="language-sh"># 1、三次回车后，密钥生成完成ssh-keygen# 2、拷贝密钥到其他节点ssh-copy-id -i ~/.ssh/id_rsa.pub  用户名字@192.168.x.xxx</code></pre><p>**、 Kubernetes要求集群中所有机器具有不同的Mac地址、产品uuid、Hostname。</p><h3 id="五、keepalived-haproxy配置"><a href="#五、keepalived-haproxy配置" class="headerlink" title="五、keepalived+haproxy配置"></a>五、keepalived+haproxy配置</h3><pre class=" language-sh"><code class="language-sh">cd ~/# 创建集群信息文件echo """CP0_IP=192.168.56.103CP1_IP=192.168.56.103CP2_IP=192.168.56.104VIP=192.168.56.102NET_IF=eth0CIDR=10.244.0.0/16""" > ./cluster-infobash -c "$(curl -fsSL https://raw.githubusercontent.com/hnbcao/kubeadm-ha-master/v1.14.0/keepalived-haproxy.sh)"</code></pre><p>安装Keepalived、Haproxy</p><ul><li><p>这是个错误的操作，并不需要在node部署keepalived+haproxy，如果node节点无法ping通虚拟IP（VIP），其原因是当前环境无法实现vip，具体原因由于能力有限，只能麻烦自己找找咯，方便分享的话不胜感激。</p></li><li><p>各个节点需要配置keepalived 和 haproxy</p></li></ul><pre class=" language-sh"><code class="language-sh">#/etc/haproxy/haproxy.cfgglobal    log         127.0.0.1 local2    chroot      /var/lib/haproxy    pidfile     /var/run/haproxy.pid    maxconn     4000    user        haproxy    group       haproxy    daemon    stats socket /var/lib/haproxy/statsdefaults    mode                    tcp    log                     global    option                  tcplog    option                  dontlognull    option                  redispatch    retries                 3    timeout queue           1m    timeout connect         10s    timeout client          1m    timeout server          1m    timeout check           10s    maxconn                 3000listen stats    mode   http    bind :10086    stats   enable    stats   uri     /admin?stats    stats   auth    admin:admin    stats   admin   if TRUEfrontend  k8s_https *:8443    mode      tcp    maxconn      2000    default_backend     https_sribackend https_sri    balance      roundrobin    server master1-api ${MASTER1_IP}:6443  check inter 10000 fall 2 rise 2 weight 1    server master2-api ${MASTER2_IP}:6443  check inter 10000 fall 2 rise 2 weight 1    server master3-api ${MASTER3_IP}:6443  check inter 10000 fall 2 rise 2 weight 1</code></pre><pre class=" language-sh"><code class="language-sh">#/etc/keepalived/keepalived.conf global_defs {    router_id LVS_DEVEL}vrrp_script check_haproxy {    script /etc/keepalived/check_haproxy.sh    interval 3}vrrp_instance VI_1 {    state MASTER    interface eth0    virtual_router_id 80    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass just0kk    }    virtual_ipaddress {        ${VIP}/24    }    track_script {           check_haproxy    }}</code></pre><pre class=" language-sh"><code class="language-sh">/etc/keepalived/check_haproxy.sh#!/bin/bashA=`ps -C haproxy --no-header |wc -l`if [ $A -eq 0 ];then/etc/init.d/keepalived stopfi</code></pre><p>注意两个配置中的${MASTER1 _ IP}, ${MASTER2 _ IP}, ${MASTER3 _ IP}、${VIP}需要替换为自己集群相应的IP地址</p><ul><li>重启keepalived和haproxy</li></ul><pre class=" language-sh"><code class="language-sh">systemctl stop keepalivedsystemctl enable keepalivedsystemctl start keepalivedsystemctl stop haproxysystemctl enable haproxysystemctl start haproxy</code></pre><h3 id="六、部署HA-Master"><a href="#六、部署HA-Master" class="headerlink" title="六、部署HA Master"></a>六、部署HA Master</h3><p>HA Master的部署过程已经自动化，请在master-1上执行如下命令，并注意修改IP;</p><p>脚本主要执行三步：</p><p>1)、重置kubelet设置</p><pre class=" language-sh"><code class="language-sh">kubeadm reset -frm -rf /etc/kubernetes/pki/</code></pre><p>2)、编写节点配置文件并初始化master1的kubelet</p><pre class=" language-sh"><code class="language-sh">echo """apiVersion: kubeadm.k8s.io/v1beta1kind: ClusterConfigurationkubernetesVersion: v1.14.0controlPlaneEndpoint: "${VIP}:8443"maxPods: 100networkPlugin: cniimageRepository: registry.aliyuncs.com/google_containersapiServer:  certSANs:  - ${CP0_IP}  - ${CP1_IP}  - ${CP2_IP}  - ${VIP}networking:  # This CIDR is a Calico default. Substitute or remove for your CNI provider.  podSubnet: ${CIDR}---apiVersion: kubeproxy.config.k8s.io/v1alpha1kind: KubeProxyConfigurationmode: ipvs""" > /etc/kubernetes/kubeadm-config.yamlkubeadm init --config /etc/kubernetes/kubeadm-config.yamlmkdir -p $HOME/.kubecp -f /etc/kubernetes/admin.conf ${HOME}/.kube/config</code></pre><ul><li>关于默认网关问题，如果有多张网卡，需要先将默认网关切换到集群使用的那张网卡上，否则可能会出现etcd无法连接等问题。（应用我用的虚拟机，有一张网卡无法做到各个节点胡同；route查看当前网关信息，route del default删除默认网关，route add default enth0设置默认网关enth0为网卡名）</li></ul><p>3)、拷贝相关证书到master2、master3</p><pre class=" language-sh"><code class="language-sh">for index in 1 2; do  ip=${IPS[${index}]}  ssh $ip "mkdir -p /etc/kubernetes/pki/etcd; mkdir -p ~/.kube/"  scp /etc/kubernetes/pki/ca.crt $ip:/etc/kubernetes/pki/ca.crt  scp /etc/kubernetes/pki/ca.key $ip:/etc/kubernetes/pki/ca.key  scp /etc/kubernetes/pki/sa.key $ip:/etc/kubernetes/pki/sa.key  scp /etc/kubernetes/pki/sa.pub $ip:/etc/kubernetes/pki/sa.pub  scp /etc/kubernetes/pki/front-proxy-ca.crt $ip:/etc/kubernetes/pki/front-proxy-ca.crt  scp /etc/kubernetes/pki/front-proxy-ca.key $ip:/etc/kubernetes/pki/front-proxy-ca.key  scp /etc/kubernetes/pki/etcd/ca.crt $ip:/etc/kubernetes/pki/etcd/ca.crt  scp /etc/kubernetes/pki/etcd/ca.key $ip:/etc/kubernetes/pki/etcd/ca.key  scp /etc/kubernetes/admin.conf $ip:/etc/kubernetes/admin.conf  scp /etc/kubernetes/admin.conf $ip:~/.kube/config  ssh ${ip} "${JOIN_CMD} --control-plane"done</code></pre><p>4)、master2、master3加入节点</p><pre class=" language-sh"><code class="language-sh">JOIN_CMD=`kubeadm token create --print-join-command`ssh ${ip} "${JOIN_CMD} --control-plane"</code></pre><p>完整脚本：</p><pre class=" language-sh"><code class="language-sh"># 部署HA masterbash -c "$(curl -fsSL https://raw.githubusercontent.com/hnbcao/kubeadm-ha-master/v1.14.0/kube-ha.sh)"</code></pre><h3 id="七、加入节点"><a href="#七、加入节点" class="headerlink" title="七、加入节点"></a>七、加入节点</h3><ul><li>节点加入命令获取</li></ul><pre class=" language-sh"><code class="language-sh">#master节点执行该命令，再在节点执行获取到的命令kubeadm token create --print-join-command</code></pre><h3 id="八、结束安装"><a href="#八、结束安装" class="headerlink" title="八、结束安装"></a>八、结束安装</h3><p>此时集群还需要安装网络组件，我选择了calico。具体安装方式可访问<a href="https://www.projectcalico.org/" target="_blank" rel="noopener">calico官网</a>，或者运行本仓库里面addons/calico下的配置。注意替换里面的镜像和Deployment里面的环境变量CALICO_IPV4POOL_CIDR为/etc/kubernetes/kubeadm-config.yaml里面networking.podSubnet的值。</p><p>文章只是在文章<a href="https://www.kubernetes.org.cn/4948.html" target="_blank" rel="noopener">kubeadm HA master(v1.13.0)离线包 + 自动化脚本 + 常用插件 For Centos/Fedora</a>的基础上，修改了master的HA方案。关于集群安装的详细步骤，建议访问<a href="https://www.kubernetes.org.cn/4948.html" target="_blank" rel="noopener">kubeadm HA master(v1.13.0)离线包 + 自动化脚本 + 常用插件 For Centos/Fedora</a>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 容器化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
