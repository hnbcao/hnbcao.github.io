<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>运行时 on HNBCAO</title>
    <link>https://hnbcao.vip/docs/golang/runtime/</link>
    <description>Recent content in 运行时 on HNBCAO</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-ch</language><atom:link href="https://hnbcao.vip/docs/golang/runtime/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1. 上下文 Context</title>
      <link>https://hnbcao.vip/docs/golang/runtime/context/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hnbcao.vip/docs/golang/runtime/context/</guid>
      <description>上下文 Context #  1.1. 方法实现 #  context.Context 是 Go 语言在 1.7 版本中引入标准库的接口1，该接口定义了四个需要实现的方法，其中包括：
  Deadline — 返回 context.Context 被取消的时间，也就是完成工作的截止日期；
  Done — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 Done 方法会返回同一个 Channel；
  Err — 返回 context.Context 结束的原因，它只会在 Done 方法对应的 Channel 关闭时返回非空的值；
  如果 context.Context 被取消，会返回 Canceled 错误；
  如果 context.Context 超时，会返回 DeadlineExceeded 错误；
    Value — 从 context.Context 中获取键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法可以用来传递请求特定的数据；</description>
    </item>
    
    <item>
      <title>2. 同步原语与锁</title>
      <link>https://hnbcao.vip/docs/golang/runtime/mutex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hnbcao.vip/docs/golang/runtime/mutex/</guid>
      <description>同步原语与锁 #  2.1. 概述 #  ​	本节会介绍 Go 语言中常见的同步原语 sync.Mutex、sync.RWMutex、sync.WaitGroup、sync.Once 和 sync.Cond 以及扩展原语 golang/sync/errgroup.Group、golang/sync/semaphore.Weighted 和 golang/sync/singleflight.Group 的实现原理，同时也会涉及互斥锁、信号量等并发编程中的常见概念。
2.2. 互斥锁（Mutex） #  2.2.1 正常模式和饥饿模式 #  sync.Mutex 有两种模式 — 正常模式和饥饿模式。我们需要在这里先了解正常模式和饥饿模式都是什么以及它们有什么样的关系。
在正常模式下，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被『饿死』。
在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。
2.2.2 加锁和解锁 #  如果互斥锁的状态不是 0 时就会调用 sync.Mutex.lockSlow 尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将它分成几个部分介绍获取锁的过程：
 判断当前 Goroutine 能否进入自旋； 通过自旋等待互斥锁的释放； 计算互斥锁的最新状态； 更新互斥锁的状态并获取锁；  2.2.3 自旋的条件 #  Goroutine 进入自旋的条件非常苛刻：</description>
    </item>
    
  </channel>
</rss>
