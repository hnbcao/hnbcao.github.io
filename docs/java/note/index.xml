<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>笔记 on HNBCAO</title>
    <link>https://hnbcao.vip/docs/java/note/</link>
    <description>Recent content in 笔记 on HNBCAO</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-ch</language><atom:link href="https://hnbcao.vip/docs/java/note/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java容器学习笔记</title>
      <link>https://hnbcao.vip/docs/java/note/collections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hnbcao.vip/docs/java/note/collections/</guid>
      <description>Java容器学习笔记 ArrayList与LinkList对比：  性能：《Java编程思想》指出，ArrayList插入移除元素较慢，ArrayList添加元素的速度比LinkList快。。LinkList插入移除元素速度优于ArrayList，且在数据量大时，ArrayList移除元素异常缓慢（按照元素顺序插入移除，若倒序插入移除则快于LinkList），其中的原因是LinkList使用双向链表存储数据，移除时只需要修改待移除元素的前后节点的next与prev位置即可，而ArrayList则涉及到数组的拷贝，倒序的情况下，ArrayList只需要将末尾元素移除即可。 建议：在涉及元素删除的List中，建议使用LinkList，其他情况可使用ArrayList。ArrayList使用在查询比较多，但是插入和删除比较少的情况，而LinkedList用在查询比较少而插入删除比较多的情况。  ArrayList、LinkList、Vector、Stack中只有Stack、Vector是线程安全的类，线程安全的List还有CopyOnWriteArrayList和Collections.synchronizedList()。Collections.synchronizedList()使用装饰模式为传入的List操作加上同步锁。 Stack底层数据结构是Vector，Vector的所有操作都加了synchronized关键字，Vector的底层使用数组保存数据，类似与ArrayList。一般多线程状态下使用List会选择Vector。 HashSet底层数据结构是HashMap LinkedHashSet底层数据结构是LinkedHashMap </description>
    </item>
    
    <item>
      <title>Spring Kafka参数配置详情</title>
      <link>https://hnbcao.vip/docs/java/note/spring-kafka-properties/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hnbcao.vip/docs/java/note/spring-kafka-properties/</guid>
      <description>Spring Kafka参数配置详情 一、全局配置 # 用逗号分隔的主机:端口对列表，用于建立到Kafka群集的初始连接。覆盖全局连接设置属性 spring.kafka.bootstrap-servers # 在发出请求时传递给服务器的ID。用于服务器端日志记录 spring.kafka.client-id，默认无 # 用于配置客户端的其他属性，生产者和消费者共有的属性 spring.kafka.properties.* # 消息发送的默认主题，默认无 spring.kafka.template.default-topic 二、生产者 Spring Boot中，Kafka 生产者相关配置(所有配置前缀为spring.kafka.producer.)：
# 生产者要求Leader在考虑请求完成之前收到的确认数 spring.kafka.producer.acks # 默认批量大小。较小的批处理大小将使批处理不太常见，并可能降低吞吐量（批处理大小为零将完全禁用批处理） spring.kafka.producer.batch-size spring.kafka.producer.bootstrap-servers # 生产者可用于缓冲等待发送到服务器的记录的总内存大小。 spring.kafka.producer.buffer-memory # 在发出请求时传递给服务器的ID。用于服务器端日志记录。 spring.kafka.producer.client-id # 生产者生成的所有数据的压缩类型 spring.kafka.producer.compression-type # 键的序列化程序类 spring.kafka.producer.key-serializer spring.kafka.producer.properties.* # 大于零时，启用失败发送的重试次数 spring.kafka.producer.retries spring.kafka.producer.ssl.key-password spring.kafka.producer.ssl.key-store-location spring.kafka.producer.ssl.key-store-password spring.kafka.producer.ssl.key-store-type spring.kafka.producer.ssl.protocol spring.kafka.producer.ssl.trust-store-location spring.kafka.producer.ssl.trust-store-password spring.kafka.producer.ssl.trust-store-type # 非空时，启用对生产者的事务支持 spring.kafka.producer.transaction-id-prefix spring.kafka.producer.value-serializer 三、消费者 Spring Boot中，Kafka 消费者相关配置(所有配置前缀为spring.kafka.consumer.)：
# 如果“enable.auto.commit”设置为true，设置消费者偏移自动提交到Kafka的频率，默认值无，单位毫秒(ms) spring.kafka.consumer.auto-commit-interval # 当Kafka中没有初始偏移或服务器上不再存在当前偏移时策略设置，默认值无，latest/earliest/none三个值设置 # earliest 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费 # latest 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据 # none topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常 spring.</description>
    </item>
    
  </channel>
</rss>
